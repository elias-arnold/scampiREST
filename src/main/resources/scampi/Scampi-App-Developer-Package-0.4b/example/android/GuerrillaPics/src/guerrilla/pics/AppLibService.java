package guerrilla.pics;

import android.app.Service;
import android.content.ComponentName;
import android.content.Context;
import android.content.Intent;
import android.content.ServiceConnection;
import android.os.Binder;
import android.os.IBinder;
import android.util.Log;
import fi.tkk.netlab.dtn.scampi.applib.AppLib;
import fi.tkk.netlab.dtn.scampi.applib.AppLibLifecycleListener;
import fi.tkk.netlab.dtn.scampi.applib.MessageReceivedCallback;
import fi.tkk.netlab.dtn.scampi.applib.PublishDoneCallback;
import fi.tkk.netlab.dtn.scampi.applib.SCAMPIMessage;

import java.io.File;
import java.io.FileNotFoundException;
import java.io.IOException;
import java.util.Collection;
import java.util.LinkedList;
import java.util.List;
import java.util.concurrent.Executors;
import java.util.concurrent.ScheduledExecutorService;
import java.util.concurrent.TimeUnit;

/**
 * Created with IntelliJ IDEA. User: teemuk Date: 10/2/13 Time: 13:45 To change
 * this template use File | Settings | File Templates.
 */
public class AppLibService
    extends Service
    implements DatabaseController.OnInserted,
    AppLibLifecycleListener, MessageReceivedCallback {
  // TODO:
  // - Synchronize the db instance variable

  //==========================================================================//
  // Constants
  //==========================================================================//
  /** SCAMPI pub/sub service name ({@value}). */
  public static final String GUERRILLA_PICS_SERVICE
      = "guerrillapics";
  /** Log tag for messages generated by this class ({@value}). */
  public static final String TAG
      = AppLibService.class.getSimpleName();
  /** Default lifetime for posted messages in seconds ({@value}). */
  public static final long MSG_LIFETIME
      = 60 * 60 * 24 * 30;
  /** Time to wait between trying to connect AppLib (milliseconds). */
  public static final long RECONNECT_PERIOD = 8000;
  //==========================================================================//


  //==========================================================================//
  // Definitions of the SCAMPIMessage fields
  //==========================================================================//
  public static final String MSG_PIC_FIELD = "pic";
  public static final String MSG_TITLE_FIELD = "title";
  public static final String MSG_TIMESTAMP_FIELD = "timestamp";
  public static final String MSG_UNIQUE_ID_FIELD = "uniqueid";
  //==========================================================================//


  //==========================================================================//
  // Instance vars
  //==========================================================================//
  /** Binder for activities */
  private IBinder binder
      = new AppLibService.AppLibBinder();
  /** Database where incoming messages are to be stored */
  private volatile DatabaseController db;
  /** AppLib connection to the router */
  private volatile AppLib appLib;
  /** Service connection to the database */
  private ServiceConnection databaseConnection;
  /**
   * Holds messages received from the AppLib before the database controller has
   * connected.
   */
  private final Collection<SCAMPIMessage> preconnectBuffer
      = new LinkedList<SCAMPIMessage>();
  /** Pic storage */
  private PicStorage picStorage;
  /** Task executor for connecting AppLib. */
  private ScheduledExecutorService scheduledExecutor;
  //==========================================================================//


  //==========================================================================//
  // API
  //==========================================================================//

  /**
   * Attempts to publish the message using the router. Returns <code>true</code>
   * if successful, <code>false</code> otherwise. Publishing may fail if there
   * is no current API connection to a router (e.g., the router is not currently
   * running).
   *
   * @param path
   *     Tag for the message.
   * @param title
   *     Content of the message.
   * @param timestamp
   *     Creation timestamp for the message.
   * @param unique
   *     Unique ID for the message.
   *
   * @return <code>true</code> if successful, <code>false</code> otherwise.
   */
  public boolean publish( String path, String title, long timestamp,
                          long unique, final long dbId ) {
    SCAMPIMessage msg = this.getScampiMessage( path, title, timestamp,
        unique );
    if ( this.appLib != null ) {
      try {
        this.appLib.publish( msg, GUERRILLA_PICS_SERVICE,
            // Add a callback to set the routed status
            new PublishDoneCallback() {
              @Override
              public void publishDone( AppLib appLib,
                                       SCAMPIMessage scampiMessage ) {
                Log.d( TAG, "Setting message '" + dbId + "' routed." );
                db.setRouted( dbId, null );
              }
            } );
      } catch ( InterruptedException e ) {
        // Swallow the exception since it can only occur when we interrupt
        // the applib ourselves.
        Log.d( TAG, "Failed to publish (" + e.getMessage() + ")" );
        return false;
      }
      return true;
    }

    return false;
  }
  //==========================================================================//


  //==========================================================================//
  // Lifecycle
  //==========================================================================//
  @Override
  public IBinder onBind( Intent intent ) {
    Log.d( TAG, "onBind()" );

    return this.binder;
  }

  @Override
  public void onCreate() {
    super.onCreate();

    this.scheduledExecutor = Executors.newSingleThreadScheduledExecutor();

    // Create Pic storage
    if ( this.picStorage == null ) {
      try {
        this.picStorage = new PicStorage( this );
      } catch ( FileNotFoundException e ) {
        Log.d( TAG, "Failed to setup picture storage (" +
                    e.getMessage() + ")." );
        return;
      }
    }

    // Create applib
    this.appLib = this.getAppLib();
    this.appLib.start();
    // Connect from a worker thread or Android complains about networking in
    // main thread.
    this.scheduleConnect( 0, TimeUnit.MILLISECONDS );

    // Bind to the database
    this.doBindDatabaseService();

    Log.d( TAG, "onCreate()" );
  }

  @Override
  public void onDestroy() {
    super.onDestroy();

    this.scheduledExecutor.shutdownNow();

    // Unbind from the database
    this.doUnbindDatabaseService();

    this.appLib.stop();

    Log.d( TAG, "onDestroy()" );
  }

  @Override
  public void onRebind( Intent intent ) {
    super.onRebind( intent );

    Log.d( TAG, "onRebind()" );
  }

  @Override
  public int onStartCommand( Intent intent, int flags, int startId ) {
    super.onStartCommand( intent, flags, startId );

    Log.d( TAG, "onStartCommand()" );

    return START_STICKY;
  }
  //==========================================================================//


  //==========================================================================//
  // Private
  //==========================================================================//
  private void handleIncomingMessage( SCAMPIMessage msg )
  throws Exception {
    Log.d( TAG, "Handling incoming message." );

    // Precondition check
    boolean hasTimestamp = msg.hasInteger( MSG_TIMESTAMP_FIELD );
    boolean hasId = msg.hasInteger( MSG_UNIQUE_ID_FIELD );
    boolean hasPic = msg.hasBinary( MSG_PIC_FIELD );
    boolean hasTitle = msg.hasString( MSG_TITLE_FIELD );

    if ( !hasTimestamp || !hasId || !hasPic || !hasTitle ) {
      Log.d( TAG, "Missing required field(s). (timestamp: "
                  + hasTimestamp + ", ID: " + hasId + ", pic: " + hasPic
                  + ", title: " + hasTitle );
      throw new IOException( "Message is missing required fields." );
    }

    // If database is not connected, add the message to pre-connect buffer
    // XXX: Is the buffer drained anywhere?
    if ( this.db == null ) {
      synchronized ( this.preconnectBuffer ) {
        if ( this.db == null ) { // Need to check again,
          // since it might have been set while
          // blocking in synchronized
          this.preconnectBuffer.add( msg );
          return;
        }
      }
    }

    // Handle the message
    long timestamp = msg.getInteger( MSG_TIMESTAMP_FIELD );
    long uniqueid = msg.getInteger( MSG_UNIQUE_ID_FIELD );
    String title = msg.getString( MSG_TITLE_FIELD );

    // Check if the message already exists in the database
    List<DatabaseController.ItemDescriptor> items
        = this.db.getItem( timestamp, uniqueid );
    if ( items.size() > 0 ) {
      // The item already exists in the database
      Log.d( TAG, "Ignoring existing message." );
      return;
    }

    // Get the message picture
    File destinationFile = this.picStorage.getEmptyFile();
    msg.moveBinary( MSG_PIC_FIELD, destinationFile );
    String picFilePath = this.picStorage.addFile( destinationFile );

    // Insert into the database
    Log.d( TAG, "Inserting message '" + title + "' : " +
                picFilePath );

    // Add insertion task to the database. This is asynchronous.
    this.db.insertItem(
        picFilePath, title,
        timestamp, uniqueid,
        true, false,
        new DatabaseController.OnInserted() {
          @Override
          public void onInserted( long id,
                                  DatabaseController.ItemDescriptor item ) {
            if ( id >= 0 ) {
              Log.d( TAG, "Message inserted (id = " + id + ")" );
            }
          }
        }
    );
  }

  private SCAMPIMessage getScampiMessage( String path, String title,
                                          long timestamp, long uniqueid ) {
    // Precondition check
    if ( path == null ) {
      throw new IllegalArgumentException(
          "Picture path cannot be null" );
    }

    // Get the picture
    File pic;
    try {
      pic = this.picStorage.getPicture( path );
    } catch ( FileNotFoundException e ) {
      throw new IllegalArgumentException( "Invalid picture, can't publish. (" +
                                          e.getMessage() + ")" );
    }
    if ( !pic.exists() || !pic.isFile() ) {
      throw new IllegalArgumentException( "Picture path must point to " +
                                          "an existing file." );
    }

    // Create the message
    SCAMPIMessage msg = new SCAMPIMessage();

    // Content items
    msg.putBinary( MSG_PIC_FIELD, pic );
    msg.putString( MSG_TITLE_FIELD, title );
    msg.putInteger( MSG_TIMESTAMP_FIELD, timestamp );
    msg.putInteger( MSG_UNIQUE_ID_FIELD, uniqueid );

    // Lifetime
    msg.setLifetime( MSG_LIFETIME );

    return msg;
  }

  /**
   * Tries to publish all unrouted entries in the database.
   */
  protected void publishUnrouted() {
    this.db.getUnrouted(
        new DatabaseController.QueryFinished() {
          @Override
          public void queryFinished(
              List<DatabaseController.ItemDescriptor> results ) {
            Log.d( TAG, "Got " + results.size() + " unrouted messages" +
                        " from the database." );

            // Publish
            for ( DatabaseController.ItemDescriptor i : results ) {
              Log.d( TAG, "Trying to publish: " +
                          "timestamp = " + i.timestamp + " " +
                          "uniqueID = " + i.uniqueid + ", routed = " +
                          i.routed );
              // Try to publish
              boolean published = AppLibService.this.publish(
                  i.path, i.title, i.timestamp,
                  i.uniqueid, i._id );

              // Mark as routed
              if ( published ) {
                Log.d( TAG, "Publish successful: id = " + i._id );
                AppLibService.this.db.setRouted( i._id, null );
              } else {
                Log.d( TAG, "Publish failed." );
                break;
              }
            }
          }
        }
    );
  }
  //==========================================================================//


  //==========================================================================//
  // AppLib handling
  //==========================================================================//
  private AppLib getAppLib() {
    AppLib applib = new AppLib();

    // Lifecycle listener
    applib.addLifecycleListener( this );

    // Setup subscription to the service
    applib.addMessageReceivedCallback( GUERRILLA_PICS_SERVICE, this );
    try {
      applib.subscribe( GUERRILLA_PICS_SERVICE );
    } catch ( InterruptedException e ) {
      Log.d( TAG, "Subscribing failed (" + e.getMessage() + ")" );
    }

    return applib;
  }

  //--------------------------------------------------------------------------//
  // MessageReceivedCallback
  //--------------------------------------------------------------------------//
  @Override
  public void messageReceived( SCAMPIMessage scampiMessage, String service ) {
    Log.d( TAG, "AppLib message received." );

    if ( GUERRILLA_PICS_SERVICE.equals( service ) ) {
      try {
        this.handleIncomingMessage( scampiMessage );
      } catch ( Exception e ) {
        Log.e( TAG, "Invalid SCAMPI message (" + e.getMessage() + ").", e );
      } finally {
        scampiMessage.close();
      }
    } else {
      Log.d( TAG, "Received message published to an incorrect service '"
                  + service + "'." );
    }
  }

  //--------------------------------------------------------------------------//
  // LifecycleListener
  //--------------------------------------------------------------------------//
  @Override
  public void onConnected( String scampiId ) {
    Log.d( TAG, "AppLib connected: " + scampiId );

    // Publish un-routed messages if database is already connected
    if ( this.db != null ) {
      this.publishUnrouted();
    }
  }

  @Override
  public void onDisconnected() {
    Log.d( TAG, "AppLib disconnected" );
    this.scheduleConnect( RECONNECT_PERIOD, TimeUnit.MILLISECONDS );
  }

  @Override
  public void onConnectFailed() {
    Log.d( TAG, "AppLib connect failed" );
    this.scheduleConnect( RECONNECT_PERIOD, TimeUnit.MILLISECONDS );
  }

  @Override
  public void onStopped() {
    Log.d( TAG, "AppLib stopped" );
    // Terminal state
  }
  //==========================================================================//


  //==========================================================================//
  // Database update listener
  //==========================================================================//
  @Override
  public void onInserted( long id, DatabaseController.ItemDescriptor item ) {
    Log.d( TAG, "Got onInserted from the database." );

    // Do nothing if AppLib is not connected.
    // When the AppLib does connect we will query the database for all
    // un-routed message and publish them in batch.
    if ( this.appLib == null ) {
      return;
    }

    // Publish if un-routed
    if ( !item.routed ) {
      Log.d( TAG, "Trying to publish item from database." );

      // Try to publish
      boolean published = AppLibService.this.publish(
          item.path, item.title, item.timestamp, item.uniqueid,
          id );

      if ( published ) {
        Log.d( TAG, "Publishing successful." );
      } else {
        Log.e( TAG, "Failed to publish." );
      }
    }
  }
  //==========================================================================//


  //==========================================================================//
  // Reconnect timer
  //==========================================================================//
  // Reconnect timer attempts to connect an AppLib instance to the router on
  // some fixed period. This allows the router process to be closed down
  // and brought up with the AppLibService connecting to it when it's
  // available.
  //--------------------------------------------------------------------------//
  private void scheduleConnect( long delay, TimeUnit unit ) {
    Log.d( TAG, "Scheduling applib connect in: " + delay + " " + unit );
    this.scheduledExecutor.schedule( new ReconnectTask( this.appLib ),
        delay, unit );
  }

  private static class ReconnectTask
      implements Runnable {
    private final AppLib appLib;

    public ReconnectTask( AppLib appLib ) {
      this.appLib = appLib;
    }

    @Override
    public void run() {
      AppLib.State state = this.appLib.getLifecycleState();
      if ( state == AppLib.State.IDLE
           || state == AppLib.State.NEW ) {
        Log.d( TAG, "Trying to connect appLib" );
        this.appLib.connect();
      } else {
        Log.d( TAG, "Can't connect, lifecycle state: " + state );
      }
    }
  }
  //==========================================================================//


  //==========================================================================//
  // Binding to DatabaseController
  //--------------------------------------------------------------------------//
  // The AppLib service binds to the database controller in order to insert
  // received messages and to publish newly generated messages.
  //==========================================================================//
  private void doBindDatabaseService() {
    this.databaseConnection = this.getServiceConnection();
    super.bindService( new Intent( this, DatabaseController.class ),
        this.databaseConnection, Context.BIND_AUTO_CREATE );
  }

  private void doUnbindDatabaseService() {
    super.unbindService( this.databaseConnection );
  }

  private ServiceConnection getServiceConnection() {
    return new ServiceConnection() {
      @Override
      public void onServiceConnected( ComponentName componentName,
                                      IBinder iBinder ) {
        Log.d( TAG, "Database connected" );

        if ( !( iBinder instanceof DatabaseController.DatabaseBinder ) ) {
          Log.e( TAG, "Wrong type of binder in onServiceConnected()" );
          return;
        }

        // Setup the database
        DatabaseController.DatabaseBinder binder =
            ( DatabaseController.DatabaseBinder ) iBinder;
        AppLibService.this.db = binder.getService();
        AppLibService.this.db.addInsertedCallback( AppLibService.this );

        // Publish un-routed messages if the AppLib is connected
        if ( appLib.getLifecycleState() == AppLib.State.CONNECTED ) {
          publishUnrouted();
        }
      }

      @Override
      public void onServiceDisconnected( ComponentName componentName ) {
        Log.d( TAG, "Database disconnected" );
        AppLibService.this.db = null;
      }
    };
  }
  //==========================================================================//


  //==========================================================================//
  // Binder
  //==========================================================================//
  public class AppLibBinder
      extends Binder {
    AppLibService getService() {
      return AppLibService.this;
    }
  }
  //==========================================================================//

}
